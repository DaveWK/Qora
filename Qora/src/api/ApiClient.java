package api;

import java.io.BufferedReader;
import java.io.IOError;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Writer;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;
import java.util.Arrays;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;

import settings.Settings;
import utils.JSonWriter;

public class ApiClient {

	String[] [] helpStrings =
		{
			{"GET qora/stop", "Will stop the application. This command might not be able to return a http OK message."},
			{"GET qora/status", "Returns the status of the application."},
			{"GET qora/isuptodate", "Shows if the application is synchronized with the network."},
			{"GET seed/<length>", "Returns a base58 encoded random seed of 32 bytes. Use the optional parameter length to request a seed of <length> bytes."},
			{"GET peers", "Returns an array of all the IP's of the peers to which the application is currently connected."},
			{"GET transactions", "Returns an array of your accounts each with their 50 last transactions."},
			{"GET transactions/limit/<limit>", "Returns an array of your accounts each with their <limit> last transactions."},
			{"GET transactions/<address>", "Returns an array of the last 50 transactions of a specific address in your wallet."},
			{"GET transactions/address/<address>", "Returns an array of the last 50 transactions of a specific address in your wallet."},
			{"GET transactions/address/<address>/limit/<limit>", "Returns an array of the last <limit> transactions of a specific address in your wallet."},
			{"GET transactions/signature/<signature>", "Returns the transaction that matches the given signature."},
			{"GET transactions/network", "Returns an array of all the unconfirmed transactions known to the client."},
			{"POST transactions/scan {\"start\": \"<startBlockSign>, \"blocklimit\":<amountBlocks>, \"transactionlimit\":<amountTransactions>, \"type\":<type>, \"service\":<service>, \"address\":\"<address>\"},", "Returns all the transactions that match the filters. All filters are optional but please limit that amount of transactions or blocks to scan to avoid running into issues. Return the last block it scanned, the amount of blocks it scanned and the scanned transactions."},
			{"GET blocks", "Returns an array of the 50 last blocks generated by your accounts."},
			{"GET blocks/address/<address>", "Returns an array of the 50 last blocks generated by a specific address in your wallet."},
			{"GET blocks/<signature>", "Returns the block that matches the given signature."},
			{"GET blocks/first", "Returns the genesis block."},
			{"GET blocks/last", "Returns the last valid block."},
			{"GET blocks/child/<signature>", "Returns the child block of the block that matches the given signature."},
			{"GET blocks/generatingbalance", "Calculates the generating balance of the block that will follow the last block."},
			{"GET blocks/generatingbalance/<signature>", "Calculates the generating balance of the block that will follow the block that matches the signature."},
			{"GET blocks/time", "Calculates the time it should take for the network to generate the next block."},
			{"GET blocks/time/<generatingbalance>", "Calculates the time it should take for the network to generate blocks when the current generating balance in the network is the specified generating balance."},
			{"GET blocks/height", "Returns the block height of the last block."},
			{"GET blocks/height/<signature>", "Returns the block height of the block that matches the given signature."},
			{"GET blocks/byheight/<height>", "Returns the block whith given height."},
			{"GET addresses", "Returns an array of all the addresses in your wallet."},
			{"GET addresses/validate/<address>", "Validates the given address. Returns true/false."},
			{"GET addresses/seed/<address>", "Returns the 32-byte long base58-encoded account seed of the given address."},
			{"GET addresses/publickey/<address>", "Returns the 32-byte long base58-encoded account publickey of the given address."},
			{"GET addresses/new", "Generates a new account and returns the newly generated address."},
			{"POST addresses <addressSeed>", "Imports the given 32-byte long base58-encoded account seed. Returns the address when successfully imported."},
			{"DELETE addresses/<address>", "Deletes the given address. Returns true/false."},
			{"GET addresses/generatingbalance/<address>", "Return the generating balance of the given address."},
			{"GET addresses/balance/<address>", "Returns the confirmed balance of the given address."},
			{"GET addresses/balance/<address>/<confirmation>", "Calculates the balance of the given address after the given confirmations."},
			{"POST addresses/sign/<address> <message>", "Signs the  given message using the given address."},
			{"POST addresses/verify/<address> {\"message\":\"<message>\", \"publickey\":\"<publickey>\", \"signature\":\"<signature>\"},", "Verifies if the given message was signed by the given address. Returns true/false."},
			{"GET wallet", "Returns general information about the wallet."},
			{"GET wallet/seed", "Return the 32-byte long base58-encoded wallet seed."},
			{"GET wallet/synchronize", "Rescans the blockchain for data."},
			{"GET wallet/lock", "Locks the wallet."},
			{"POST wallet {\"seed\":\"/<seed>\", \"password\":\"<password>\", \"recover\":<false/true>,  \"amount\":<amount>} ", "Creates a wallet using the given 32-byte long base58-encoded seed, password,recover flag and amount."},
			{"POST wallet/unlock <password>", "Unlocks the wallet using the given password. Returns true/false depending on the fact if the password is correct.\n201 - Wallet does not exist."},
			{"POST payment {\"amount\":\"<amount>\", \"fee\":\"<fee>, \"sender\":\"<senderAddress>\", \"recipient\":\"<recipient>\"},", "Send a new payment using the given data. Returns the transaction in JSON when successful."},
			{"POST namepayment {\"amount\":\"<amount>\", \"fee\":\"<fee>\", \"sender\":\"<senderAddress>\", \"recipient\":\"<recipientName>\"},", "Send a new neme-payment using the given data."},
			{"GET names", "Returns an array of all the names owned by your accounts."},
			{"GET names/address/<address>", "Returns an array of all the names owned by a specific address in your wallet."},
			{"GET names/<name>", "Returns details about the given name"},
			{"POST names {\"name\":\"<name>\", \"value\":\"<value>\", \"registrant\":\"registrantAddress\", \"fee\":\"<fee>\"},", "Register a new name. Returns the transaction in JSON when successful."},
			{"POST names/<name> {\"newvalue\":\"<newvalue>\", \"newowner\":\"<newownerAddress>\", \"fee\":\"<fee>\"},", "Updates an existing name. Returns the transaction in JSON when successful."},
			{"GET namesales", "Returns an array of all the namesales owned by your accounts."},
			{"GET namesales/address/<address>", "Returns an array of all the namesales owned by a specific address in your wallet."},
			{"GET namesales/<name>", "Return details about the given name that is for sale."},
			{"GET namesales/network", "Returns an array of all the names that are for sale. For performance this array only contains the keys of the names that are for sale and not the details."},
			{"POST namesales/<name> {\"amount\":\"<amount>\", \"fee\":\"<fee>\"},", "Used to sell the given name. Returns the transaction in JSON when successful."},
			{"DELETE namesales/<name>/<fee>", "Used to cancel the sale of the given name. Returns the transaction in JSON when successful."},
			{"POST namesales/buy/<name> {\"buyer\":\"<buyerAddress>\", \"fee\":\"<fee>\"},", "Used to purchase the given name. Returns the transaction in JSON when successful."},
			{"GET polls", "Returns an array of all the polls created by your accounts."},
			{"GET polls/address/<address>", "Returns an array of all the polls owned by a specific address in your wallet."},
			{"GET polls/<name>", "Return details about the poll with the given name."},
			{"GET polls/network", "Returns an array of all the polls. For performance this array only contains the names of the polls and not the details."},
			{"POST polls {\"creator\":\"<creatorAddress>\", \"name\":\"<name>\", \"description\":\"<description>\", \"options\": [<optionOne>, <optionTwo>], \"fee\":\"<fee>\"},", "Used to create a new poll. Returns the transaction in JSON when successful."},
			{"POST polls/vote/<name> {\"voter\":\"<voterAddress>\", \"option\": \"<optionOne>\", \"fee\":\"<fee>\"},", "Used to vote on a poll with the given name. Returns the transaction in JSON when successful."},
			{"POST arbitrarytransactions {\"creator\":\"<creatorAddress>\", \"data\":\"<dataBase58>\", \"service\": <service>, \"fee\":\"<fee>\"},", "Used to send an arbitrary transaction. The data of the arbitrary transaction must be base58 encoded and must be between 1-4000 bytes. Returns the transaction in JSON when successful."},
			{"GET at", "Returns an array of all the Automated Transactions accounts."},
			{"GET at/id/<id>", "Return details about AT account with the given assress."},
			{"GET at/transactions/id/<sender>", "Returns an array of all the AT transactions with the given sender."},
			{"GET at/creator/<creator>", "Returns an array of all the AT transactions with the given creator."},
			{"GET at/type/<type>", "Returns an array of AT accounts with the given type."},
			{"GET at/transactions/recipient/<recipient>", "Returns an array of all the AT transactions with the given recipient."},
			{"GET at/limit/<limit>", "Returns an array of AT accounts with creationBlock more then given."},
			{"POST at {\"creator\": \"creatorAddress\", \"name\": \"<name>\", \"description\": \"<description>\", \"type\": \"<type>\", \"tags\": \"<tags>\", \"fee\": \"<fee>\", \"quantity\": \"<quantity>\", \"code\": \"<code>\", \"data\": \"<dataHex>\", \"dpages\": \"<dpages>\", \"cspages\": \"<cspages>\", \"uspages\": \"<uspages>\"},", "Used to create a new AT account. Returns the transaction in JSON when successful."},
		};
	
	
	public String executeCommand(String command)
	{
		if(command.toLowerCase().equals("help all"))
		{
			String help = "\n";
			
			for (String[] strings : helpStrings) {
				help += strings[0] + "\n\t" + strings[1] + "\n\n"; 
			}
			
			return help;
		}

		if(command.toLowerCase().startsWith("help"))
		{
			command = command.substring(4, command.length()).toLowerCase(); 
			String[] args = command.split("[ /]");
			
			String help = "";
			
			if(args.length>1)
			{
				boolean found = false;
				for (String[] helpString : helpStrings) {

					String[] helparray = helpString[0].toLowerCase().split("[ /<>]");
					
					boolean notallfound = false;
					for (String string : args) 
					{
						if(string.equals(""))
						{
							continue;
						}

						if(Arrays.asList(helparray).indexOf(string) == -1)
						{
							notallfound = true;
						}
					}
						
					if(!notallfound)
					{
						help += helpString[0] + "\n\t" + helpString[1] + "\n\n";
						found = true;
					}
				}
				if(!found)
				{
					help += "Command not found!\n";

				}
			}
			else
			{
				help = "\n";
				for (String[] helpString : helpStrings) {
					help += helpString[0] + "\n"; 
				}
			}
			
			help += "\nType \"help all\" for detailed help for all commands. Or enter \"help command\" to get detailed help for that command.\n";
			
			return help;
		}
		
		try
		{
			//SPLIT
			String[] args = command.split(" ");
			
			//GET METHOD
			String method = args[0].toUpperCase();
			
			//GET PATH
			String path = args[1];
			
			//GET CONTENT
			String content = "";
			if(method.equals("POST"))
			{
				content = command.substring((method + " " + path + " ").length());
			}
			
			//URL CANNOT CONTAIN UNICODE CHARACTERS
			String[] paths = path.split("/");
			String path2 = "";
			for (String string : paths) {
				path2 += URLEncoder.encode(string, "UTF-8") + "/";
			}
			path2 = path2.substring(0,path2.length()-1);
			
			//CREATE CONNECTION
			URL url = new URL("http://127.0.0.1:" + Settings.getInstance().getRpcPort() + "/" + path2);
			HttpURLConnection connection = (HttpURLConnection) url.openConnection();
			
			//EXECUTE
			connection.setRequestMethod(method);
			
			if(method.equals("POST"))
			{
				connection.setDoOutput(true);
				connection.getOutputStream().write(content.getBytes("UTF-8"));
				connection.getOutputStream().flush();
				connection.getOutputStream().close();
			}
			
			//READ RESULT
			InputStream stream;
			if(connection.getResponseCode() == 400)
			{
				stream = connection.getErrorStream();
			}
			else
			{
				stream = connection.getInputStream();
			}

			InputStreamReader isReader = new InputStreamReader(stream, "UTF-8"); 
			BufferedReader br = new BufferedReader(isReader);
			String result = br.readLine(); //TODO READ ALL OR HARDCODE HELP
			
			try
			{
				Writer writer = new JSonWriter();
				Object jsonResult = JSONValue.parse(result);
				
				if(jsonResult instanceof JSONArray)
				{
					((JSONArray) jsonResult).writeJSONString(writer);
					return writer.toString();
				}
				if(jsonResult instanceof JSONObject)
				{
					((JSONObject) jsonResult).writeJSONString(writer);
					return writer.toString();
				}
				
				writer.close();
				return result;
			}
			catch(Exception e)
			{
				return result;
			}
			
		}
		catch(IOError ioe)
		{
			//ioe.printStackTrace();	
			return "Invalid command! \n" +
				"Type help to get a list of commands.";
		}
		catch(Exception e)
		{
			//e.printStackTrace();	
			return "Invalid command! \n" +
				"Type help to get a list of commands.";
		}
	}
}
